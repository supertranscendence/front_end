import { isObject, canUseDOM, getAllFocusable } from '@chakra-ui/utils';
export { canUseDOM } from '@chakra-ui/utils';
import { isVNode, provide, inject, ref, onBeforeUpdate, unref, customRef, getCurrentScope, onScopeDispose } from 'vue';

/**
 * Creates a named context, provider, and hook.
 *
 * @param options create context options
 */
function createContext(options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$strict = _options.strict,
      strict = _options$strict === void 0 ? true : _options$strict,
      _options$errorMessage = _options.errorMessage,
      errorMessage = _options$errorMessage === void 0 ? "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider" : _options$errorMessage,
      name = _options.name;
  var contextSymbol = Symbol(name + "Symbol");

  function Provider(payload) {
    provide(contextSymbol, payload);
  }

  function useContext(fallback) {
    if (fallback === void 0) {
      fallback = null;
    }

    var context = inject(contextSymbol, fallback);

    if (!context && strict) {
      throw new Error(errorMessage);
    }

    return context;
  }

  return [Provider, useContext];
}
/**
 * Gets only the valid children of a component,
 * and ignores any nullish or falsy child.
 *
 * @param slots vue slots
 *
 * see https://github.com/vuejs/vue-next/blob/HEAD/packages/runtime-core/src/helpers/renderSlot.ts
 */

function getValidChildren(slots) {
  var slotArray = (slots == null ? void 0 : slots["default"] == null ? void 0 : slots["default"]()) || [];
  return slotArray.filter(function (child) {
    return isVNode(child);
  });
}

/** Checkes whether a provided object is a component */
function isObjectComponent(subject) {
  var validComponentTypes = ["function", "object"];
  if (!validComponentTypes.includes(typeof subject)) return false; // Is sub

  if (isObject(subject)) {
    // Is object component with render function
    if (typeof (subject == null ? void 0 : subject.render) === "function" && isVNode(subject.render())) return true; // Is object component with setup function
    else if (typeof (subject == null ? void 0 : subject.setup) === "function") return true;
  }

  return false;
}

function orient(options) {
  var orientation = options.orientation,
      vertical = options.vertical,
      horizontal = options.horizontal;
  if (!orientation) return {};
  return orientation === "vertical" ? vertical : horizontal;
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/** Debounce function */
function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (immediate && !timeout) func.apply(void 0, args);
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      func.apply(void 0, args);
    }, wait);
  };
}

/**
 * For internal use
 *
 * Creates refs that will be bound to the template/render function.
 *
 * Why not just use the regular `ref(null)` and bind it to the element?
 *
 * 1. To avoid unwrapping template refs which maybe components. This hook will always
 *    give us the actual element being bound the the element, and not the component
 *    options.
 *
 * 2. In some cases where we need an up-to-date value of the ref node,
 *    from the consuming component, we can use this hook.
 *
 * @returns []
 */
function useRef() {
  var refEl = ref(null);
  onBeforeUpdate(function () {
    // clear refs before DOM updates
    refEl.value = null;
  });
  /**
   * Getter function to bind ref to value
   * @param el Template ref value provided by Vue
   */

  var _ref = function _ref(el) {
    var _$el;

    refEl.value = (_$el = el == null ? void 0 : el.$el) != null ? _$el : el;
  };

  return [_ref, refEl];
}
/** Vue Component HTML Element Instance */

/**
 * Unwraps element from ref
 * @param elementRef Ref of template node
 */
function unrefElement(elementRef) {
  var _$el2;

  var node = unref(elementRef);
  return (_$el2 = node == null ? void 0 : node.$el) != null ? _$el2 : node;
}
/**
 * Creates a ref whose value updates are debounced
 *
 * @example Simple example
 *
 * ```ts
 * const foo = useDebouncedRef('bar')
 * foo.value = 'baz'
 *
 * // foo.value to be updated to 'baz' after the delay of 300ms
 * ```
 *
 * @example Custom delay
 *
 * ```ts
 * const foo = useDebouncedRef('bar', 500)
 * foo.value = 'baz'
 *
 * // foo.value to be updated to 'baz' after the delay of 500ms
 * ```
 */

function useDebouncedRef(initialValue, delay, immediate) {
  if (delay === void 0) {
    delay = 300;
  }

  if (immediate === void 0) {
    immediate = false;
  }

  var state = ref(initialValue);
  var debouncedRef = customRef(function (track, trigger) {
    return {
      get: function get() {
        track();
        return state.value;
      },
      set: debounce(function (value) {
        state.value = value;
        trigger();
      }, delay, immediate)
    };
  });
  return debouncedRef;
}
function contains(containers, element) {
  for (var _iterator = _createForOfIteratorHelperLoose(containers), _step; !(_step = _iterator()).done;) {
    var container = _step.value;
    if (container.contains(element)) return true;
  }

  return false;
}

/**
 * Computes the selector of an element from the DOM
 *
 * The motivation for this method is to use it in the
 * resolve the issue where DOM nodes seem to be
 * removed from the DOM during patching for reactivity.
 *
 * This was breaking the behaviour of the `useFocusLock`
 * hook.
 *
 * Adopted from stack overflow:
 * https://stackoverflow.com/questions/22515835/javascript-find-selector-of-an-element
 */
function getSelector(node) {
  var id = node.getAttribute("id");
  if (id) return "#" + id;
  var path = "";

  var _loop = function _loop() {
    var name = node.localName;
    var parent = node.parentNode;

    if (!parent) {
      path = name + " > " + path;
      return "continue";
    }

    if (node.getAttribute("id")) {
      path = "#" + node.getAttribute("id") + " > " + path;
      return "break";
    }

    var sameTagSiblings = [];
    var children = parent.childNodes;
    children = Array.prototype.slice.call(children);
    children.forEach(function (child) {
      // @ts-ignore
      if (child.localName == name) {
        sameTagSiblings.push(child);
      }
    }); // if there are more than one
    // children of that type use nth-of-type

    if (sameTagSiblings.length > 1) {
      var index = sameTagSiblings.indexOf(node);
      name += ":nth-of-type(" + (index + 1) + ")";
    }

    if (path) {
      path = name + " > " + path;
    } else {
      path = name;
    }

    node = parent;
  };

  while (node) {
    var _ret = _loop();

    if (_ret === "continue") continue;
    if (_ret === "break") break;
  }

  return path;
}

var vueThemingProps = {
  colorScheme: String,
  variant: String,
  size: String,
  styleConfig: String
};
var SNA = [Number, String, Array];
var SAO = [String, Array, Object];
var SNAO = [Number, String, Array, Object];

/**
 * Invokes onScopeDispose() if it's inside a effect scope lifecycle, if not, do nothing
 *
 * @param fn
 */
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }

  return false;
}

var defaultWindow = canUseDOM() ? window : null;

/**
 * Credit:
 * Adapted from the good folks at @headlessui/vue
 */
function match(value, lookup) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  if (value in lookup) {
    var returnValue = lookup[value];
    return typeof returnValue === "function" ? returnValue.apply(void 0, args) : returnValue;
  }

  var error = new Error("Tried to handle \"" + value + "\" but there is no handler defined. Only defined handlers are: " + Object.keys(lookup).map(function (key) {
    return "\"" + key + "\"";
  }).join(", ") + ".");
  /** @ts-expect-error "captureStackTrace" not in default Error constuctor typee  */

  if (Error != null && Error.captureStackTrace) Error.captureStackTrace(error, match);
  throw error;
}

var Keys;

(function (Keys) {
  Keys["Space"] = " ";
  Keys["Enter"] = "Enter";
  Keys["Escape"] = "Escape";
  Keys["Backspace"] = "Backspace";
  Keys["ArrowLeft"] = "ArrowLeft";
  Keys["ArrowUp"] = "ArrowUp";
  Keys["ArrowRight"] = "ArrowRight";
  Keys["ArrowDown"] = "ArrowDown";
  Keys["Home"] = "Home";
  Keys["End"] = "End";
  Keys["PageUp"] = "PageUp";
  Keys["PageDown"] = "PageDown";
  Keys["Tab"] = "Tab";
})(Keys || (Keys = {}));

/** Contains some helpers to extend the focus utils in @chakra-ui/utils */
var Focus;

(function (Focus) {
  Focus[Focus["First"] = 1] = "First";
  Focus[Focus["Previous"] = 2] = "Previous";
  Focus[Focus["Next"] = 4] = "Next";
  Focus[Focus["Last"] = 8] = "Last";
  Focus[Focus["WrapAround"] = 16] = "WrapAround";
  Focus[Focus["NoScroll"] = 32] = "NoScroll";
})(Focus || (Focus = {}));

var FocusResult;

(function (FocusResult) {
  FocusResult[FocusResult["Error"] = 0] = "Error";
  FocusResult[FocusResult["Overflow"] = 1] = "Overflow";
  FocusResult[FocusResult["Success"] = 2] = "Success";
  FocusResult[FocusResult["Underflow"] = 3] = "Underflow";
})(FocusResult || (FocusResult = {}));

var Direction;

(function (Direction) {
  Direction[Direction["Previous"] = -1] = "Previous";
  Direction[Direction["Next"] = 1] = "Next";
})(Direction || (Direction = {}));

function focusElement(element) {
  element == null ? void 0 : element.focus({
    preventScroll: true
  });
}
function focusIn(container, focus) {
  var elements = Array.isArray(container) ? container.slice().sort(function (a, z) {
    var position = a.compareDocumentPosition(z);
    if (position & Node.DOCUMENT_POSITION_FOLLOWING) return -1;
    if (position & Node.DOCUMENT_POSITION_PRECEDING) return 1;
    return 0;
  }) : function () {
    var focusables = getAllFocusable(container).filter(function (el) {
      return el !== container;
    });
    return focusables;
  }();
  var active = document.activeElement;

  var direction = function () {
    if (focus & (Focus.First | Focus.Next)) return Direction.Next;
    if (focus & (Focus.Previous | Focus.Last)) return Direction.Previous;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  }();

  var startIndex = function () {
    if (focus & Focus.First) return 0;
    if (focus & Focus.Previous) return Math.max(0, elements.indexOf(active)) - 1;
    if (focus & Focus.Next) return Math.max(0, elements.indexOf(active)) + 1;
    if (focus & Focus.Last) return elements.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  }();

  var focusOptions = focus & Focus.NoScroll ? {
    preventScroll: true
  } : {};
  var offset = 0;
  var total = elements.length;
  var next = undefined;

  do {
    var _next;

    // Guard against infinite loops
    if (offset >= total || offset + total <= 0) return FocusResult.Error;
    var nextIdx = startIndex + offset;

    if (focus & Focus.WrapAround) {
      nextIdx = (nextIdx + total) % total;
    } else {
      if (nextIdx < 0) return FocusResult.Underflow;
      if (nextIdx >= total) return FocusResult.Overflow;
    }

    next = elements[nextIdx]; // Try the focus the next element, might not work if it is "hidden" to the user.

    (_next = next) == null ? void 0 : _next.focus(focusOptions); // Try the next one in line

    offset += direction;
  } while (next !== document.activeElement); // This is a little weird, but let me try and explain: There are a few scenario's
  // in chrome for example where a focused `<a>` tag does not get the default focus
  // styles and sometimes they do. This highly depends on whether you started by
  // clicking or by using your keyboard. When you programmatically add focus `anchor.focus()`
  // then the active element (document.activeElement) is this anchor, which is expected.
  // However in that case the default focus styles are not applied *unless* you
  // also add this tabindex.


  if (!next.hasAttribute("tabindex")) next.setAttribute("tabindex", "0");
  return FocusResult.Success;
}

export { Focus, FocusResult, Keys, SAO, SNA, SNAO, contains, createContext, debounce, defaultWindow, focusElement, focusIn, getSelector, getValidChildren, isObjectComponent, match, orient, tryOnScopeDispose, unrefElement, useDebouncedRef, useRef, vueThemingProps };
