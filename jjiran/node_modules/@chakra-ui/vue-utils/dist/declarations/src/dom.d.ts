import { defineComponent, Ref, UnwrapRef } from "vue";
import { MaybeRef } from "./types";
/**
 * Interface for node provided by template ref
 */
export declare type TemplateRef = Element | VueComponentInstance | undefined | null;
/**
 * For internal use
 *
 * Creates refs that will be bound to the template/render function.
 *
 * Why not just use the regular `ref(null)` and bind it to the element?
 *
 * 1. To avoid unwrapping template refs which maybe components. This hook will always
 *    give us the actual element being bound the the element, and not the component
 *    options.
 *
 * 2. In some cases where we need an up-to-date value of the ref node,
 *    from the consuming component, we can use this hook.
 *
 * @returns []
 */
export declare function useRef(): [
    (el: TemplateRef | null) => void,
    Ref<HTMLElement | null>
];
/** Vue Component HTML Element Instance */
export declare type VueComponentInstance = InstanceType<ReturnType<typeof defineComponent>>;
/** Ref may or may not be an HTML Element or VueComponent instance */
export declare type MaybeElementRef = MaybeRef<Element | VueComponentInstance | undefined | null>;
/**
 * Unwraps element from ref
 * @param elementRef Ref of template node
 */
export declare function unrefElement(elementRef: MaybeElementRef): UnwrapRef<MaybeElementRef>;
/**
 * Creates a ref whose value updates are debounced
 *
 * @example Simple example
 *
 * ```ts
 * const foo = useDebouncedRef('bar')
 * foo.value = 'baz'
 *
 * // foo.value to be updated to 'baz' after the delay of 300ms
 * ```
 *
 * @example Custom delay
 *
 * ```ts
 * const foo = useDebouncedRef('bar', 500)
 * foo.value = 'baz'
 *
 * // foo.value to be updated to 'baz' after the delay of 500ms
 * ```
 */
export declare function useDebouncedRef<T = unknown>(initialValue: T, delay?: number, immediate?: boolean): Ref<UnwrapRef<T>>;
export declare type DebouncedRef = Ref<unknown>;
export declare function contains(containers: Set<HTMLElement>, element: HTMLElement): boolean;
//# sourceMappingURL=dom.d.ts.map